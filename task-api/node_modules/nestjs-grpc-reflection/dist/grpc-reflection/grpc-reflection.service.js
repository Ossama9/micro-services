"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GrpcReflectionService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcReflectionService = exports.ReflectionError = void 0;
const descriptor_pb_1 = require("google-protobuf/google/protobuf/descriptor_pb");
const grpc = require("@grpc/grpc-js");
const protoLoader = require("@grpc/proto-loader");
const common_1 = require("@nestjs/common");
const grpc_reflection_constants_1 = require("./grpc-reflection.constants");
const protobuf_visitor_1 = require("./protobuf-visitor");
class ReflectionError extends Error {
    constructor(statusCode, message) {
        super(message);
        this.statusCode = statusCode;
        this.message = message;
    }
}
exports.ReflectionError = ReflectionError;
let GrpcReflectionService = GrpcReflectionService_1 = class GrpcReflectionService {
    constructor(grpcConfig) {
        this.grpcConfig = grpcConfig;
        this.logger = new common_1.Logger(GrpcReflectionService_1.name);
        this.fileDescriptorSet = new descriptor_pb_1.FileDescriptorSet();
        this.fileNameIndex = {};
        this.extensionIndex = {};
        this.symbolMap = {};
    }
    async onModuleInit() {
        const { protoPath, loader } = this.grpcConfig.options;
        const protoFiles = Array.isArray(protoPath) ? protoPath : [protoPath];
        const packageDefinitions = await Promise.all(protoFiles.map((file) => protoLoader.load(file, loader)));
        packageDefinitions.forEach((packageDefinition) => {
            Object.values(packageDefinition).forEach(({ fileDescriptorProtos }) => {
                if (Array.isArray(fileDescriptorProtos)) {
                    fileDescriptorProtos.forEach((bin) => {
                        const proto = descriptor_pb_1.FileDescriptorProto.deserializeBinary(bin);
                        const isFileInSet = this.fileDescriptorSet
                            .getFileList()
                            .map((f) => f.getName())
                            .includes(proto.getName());
                        if (!isFileInSet) {
                            this.fileDescriptorSet.addFile(proto);
                        }
                    });
                }
            });
        });
        this.fileNameIndex = Object.fromEntries(this.fileDescriptorSet.getFileList().map((f) => [f.getName(), f]));
        const index = (fqn, file) => (this.symbolMap[fqn] = file);
        this.fileDescriptorSet.getFileList().forEach((file) => (0, protobuf_visitor_1.visit)(file, {
            field: index,
            oneOf: index,
            message: index,
            service: index,
            method: index,
            enum: index,
            enumValue: index,
            extension: (fqn, file, ext) => {
                index(fqn, file);
                const extendeeName = ext.getExtendee();
                this.extensionIndex[extendeeName] = Object.assign(Object.assign({}, (this.extensionIndex[extendeeName] || {})), { [ext.getNumber()]: file });
            },
        }));
        const addReference = (ref, sourceFile) => {
            if (!ref) {
                return;
            }
            let referencedFile = null;
            if (ref.startsWith('.')) {
                referencedFile = this.symbolMap[ref.replace(/^\./, '')];
            }
            else {
                referencedFile = this.symbolMap[ref];
                if (!referencedFile) {
                    referencedFile = this.symbolMap[`${sourceFile.getPackage()}.${ref}`];
                }
            }
            if (!referencedFile) {
                this.logger.warn(`Could not find file associated with reference ${ref}`);
                return;
            }
            if (referencedFile !== sourceFile) {
                sourceFile.addDependency(referencedFile.getName());
            }
        };
        this.fileDescriptorSet.getFileList().forEach((file) => (0, protobuf_visitor_1.visit)(file, {
            field: (_fqn, file, field) => addReference(field.getTypeName(), file),
            extension: (_fqn, file, ext) => addReference(ext.getTypeName(), file),
            method: (_fqn, file, method) => {
                addReference(method.getInputType(), file);
                addReference(method.getOutputType(), file);
            },
        }));
    }
    listServices(listServices) {
        this.logger.debug(`listServices called with filter ${listServices}`);
        const services = this.fileDescriptorSet
            .getFileList()
            .map((file) => file
            .getServiceList()
            .map((service) => `${file.getPackage()}.${service.getName()}`))
            .flat();
        this.logger.debug(`listServices found services: ${services.join(', ')}`);
        return { service: services.map((service) => ({ name: service })) };
    }
    fileContainingSymbol(symbol) {
        this.logger.debug(`fileContainingSymbol called for symbol ${symbol}`);
        const file = this.symbolMap[symbol];
        if (!file) {
            this.logger.error(`fileContainingSymbol failed to find symbol ${symbol}`);
            throw new ReflectionError(grpc.status.NOT_FOUND, `Symbol not found: ${symbol}`);
        }
        const deps = this.getFileDependencies(file);
        this.logger.debug(`fileContainingSymbol found files: ${[file, ...deps].map((f) => f.getName())}`);
        return {
            fileDescriptorProto: [file, ...deps].map((proto) => proto.serializeBinary()),
        };
    }
    fileByFilename(filename) {
        this.logger.debug(`fileByFilename called with filename ${filename}`);
        const file = this.fileNameIndex[filename];
        if (!file) {
            throw new ReflectionError(grpc.status.NOT_FOUND, `Proto file not found: ${filename}`);
        }
        const deps = this.getFileDependencies(file);
        this.logger.debug(`fileByFilename found files: ${[file, ...deps].map((f) => f.getName())}`);
        return {
            fileDescriptorProto: [file, ...deps].map((f) => f.serializeBinary()),
        };
    }
    fileContainingExtension(symbol, field) {
        const extensionsByFieldNumber = this.extensionIndex[symbol] || {};
        const file = extensionsByFieldNumber[field];
        if (!file) {
            throw new ReflectionError(grpc.status.NOT_FOUND, `Extension not found for symbol ${symbol} at field ${field}`);
        }
        const deps = this.getFileDependencies(file);
        this.logger.debug(`fileContainingExtension found files: ${[file, ...deps].map((f) => f.getName())}`);
        return {
            fileDescriptorProto: [file, ...deps].map((f) => f.serializeBinary()),
        };
    }
    allExtensionNumbersOfType(symbol) {
        if (!(symbol in this.extensionIndex)) {
            throw new ReflectionError(grpc.status.NOT_FOUND, `Extensions not found for symbol ${symbol}`);
        }
        const fieldNumbers = Object.keys(this.extensionIndex[symbol]).map((key) => Number(key));
        return {
            baseTypeName: symbol,
            extensionNumber: fieldNumbers,
        };
    }
    getFileDependencies(file, visited = new Set()) {
        const newVisited = visited.add(file);
        const directDeps = file
            .getDependencyList()
            .map((dep) => this.fileNameIndex[dep]);
        const transitiveDeps = directDeps
            .filter((dep) => !newVisited.has(dep))
            .map((dep) => this.getFileDependencies(dep, newVisited))
            .flat();
        const allDeps = [...directDeps, ...transitiveDeps];
        return [...new Set(allDeps)];
    }
};
GrpcReflectionService = GrpcReflectionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)(grpc_reflection_constants_1.GRPC_CONFIG_PROVIDER_TOKEN)),
    __metadata("design:paramtypes", [Object])
], GrpcReflectionService);
exports.GrpcReflectionService = GrpcReflectionService;
//# sourceMappingURL=grpc-reflection.service.js.map